/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * The DialFfi interface, returned as a pointer by init_rust_runtime. User should keep this pointer until freeing the runtime.
 */
typedef struct DialFfi DialFfi;

/**
 * A array-based statically sized matrix data storage.
 */
typedef double ArrayStorage_f64__3__1[1][3];

/**
 * The most generic column-major matrix (and vector) type.
 *
 * # Methods summary
 * Because `Matrix` is the most generic types used as a common representation of all matrices and
 * vectors of **nalgebra** this documentation page contains every single matrix/vector-related
 * method. In order to make browsing this page simpler, the next subsections contain direct links
 * to groups of methods related to a specific topic.
 *
 * #### Vector and matrix construction
 * - [Constructors of statically-sized vectors or statically-sized matrices](#constructors-of-statically-sized-vectors-or-statically-sized-matrices)
 *   (`Vector3`, `Matrix3x6`…)
 * - [Constructors of fully dynamic matrices](#constructors-of-fully-dynamic-matrices) (`DMatrix`)
 * - [Constructors of dynamic vectors and matrices with a dynamic number of rows](#constructors-of-dynamic-vectors-and-matrices-with-a-dynamic-number-of-rows)
 *   (`DVector`, `MatrixXx3`…)
 * - [Constructors of matrices with a dynamic number of columns](#constructors-of-matrices-with-a-dynamic-number-of-columns)
 *   (`Matrix2xX`…)
 * - [Generic constructors](#generic-constructors)
 *   (For code generic wrt. the vectors or matrices dimensions.)
 *
 * #### Computer graphics utilities for transformations
 * - [2D transformations as a Matrix3 <span style="float:right;">`new_rotation`…</span>](#2d-transformations-as-a-matrix3)
 * - [3D transformations as a Matrix4 <span style="float:right;">`new_rotation`, `new_perspective`, `look_at_rh`…</span>](#3d-transformations-as-a-matrix4)
 * - [Translation and scaling in any dimension <span style="float:right;">`new_scaling`, `new_translation`…</span>](#translation-and-scaling-in-any-dimension)
 * - [Append/prepend translation and scaling <span style="float:right;">`append_scaling`, `prepend_translation_mut`…</span>](#appendprepend-translation-and-scaling)
 * - [Transformation of vectors and points <span style="float:right;">`transform_vector`, `transform_point`…</span>](#transformation-of-vectors-and-points)
 *
 * #### Common math operations
 * - [Componentwise operations <span style="float:right;">`component_mul`, `component_div`, `inf`…</span>](#componentwise-operations)
 * - [Special multiplications <span style="float:right;">`tr_mul`, `ad_mul`, `kronecker`…</span>](#special-multiplications)
 * - [Dot/scalar product <span style="float:right;">`dot`, `dotc`, `tr_dot`…</span>](#dotscalar-product)
 * - [Cross product <span style="float:right;">`cross`, `perp`…</span>](#cross-product)
 * - [Magnitude and norms <span style="float:right;">`norm`, `normalize`, `metric_distance`…</span>](#magnitude-and-norms)
 * - [In-place normalization <span style="float:right;">`normalize_mut`, `try_normalize_mut`…</span>](#in-place-normalization)
 * - [Interpolation <span style="float:right;">`lerp`, `slerp`…</span>](#interpolation)
 * - [BLAS functions <span style="float:right;">`gemv`, `gemm`, `syger`…</span>](#blas-functions)
 * - [Swizzling <span style="float:right;">`xx`, `yxz`…</span>](#swizzling)
 * - [Triangular matrix extraction <span style="float:right;">`upper_triangle`, `lower_triangle`</span>](#triangular-matrix-extraction)
 *
 * #### Statistics
 * - [Common operations <span style="float:right;">`row_sum`, `column_mean`, `variance`…</span>](#common-statistics-operations)
 * - [Find the min and max components <span style="float:right;">`min`, `max`, `amin`, `amax`, `camin`, `cmax`…</span>](#find-the-min-and-max-components)
 * - [Find the min and max components (vector-specific methods) <span style="float:right;">`argmin`, `argmax`, `icamin`, `icamax`…</span>](#find-the-min-and-max-components-vector-specific-methods)
 *
 * #### Iteration, map, and fold
 * - [Iteration on components, rows, and columns <span style="float:right;">`iter`, `column_iter`…</span>](#iteration-on-components-rows-and-columns)
 * - [Elementwise mapping and folding <span style="float:right;">`map`, `fold`, `zip_map`…</span>](#elementwise-mapping-and-folding)
 * - [Folding or columns and rows <span style="float:right;">`compress_rows`, `compress_columns`…</span>](#folding-on-columns-and-rows)
 *
 * #### Vector and matrix slicing
 * - [Creating matrix slices from `&[T]` <span style="float:right;">`from_slice`, `from_slice_with_strides`…</span>](#creating-matrix-slices-from-t)
 * - [Creating mutable matrix slices from `&mut [T]` <span style="float:right;">`from_slice_mut`, `from_slice_with_strides_mut`…</span>](#creating-mutable-matrix-slices-from-mut-t)
 * - [Slicing based on index and length <span style="float:right;">`row`, `columns`, `slice`…</span>](#slicing-based-on-index-and-length)
 * - [Mutable slicing based on index and length <span style="float:right;">`row_mut`, `columns_mut`, `slice_mut`…</span>](#mutable-slicing-based-on-index-and-length)
 * - [Slicing based on ranges <span style="float:right;">`rows_range`, `columns_range`…</span>](#slicing-based-on-ranges)
 * - [Mutable slicing based on ranges <span style="float:right;">`rows_range_mut`, `columns_range_mut`…</span>](#mutable-slicing-based-on-ranges)
 *
 * #### In-place modification of a single matrix or vector
 * - [In-place filling <span style="float:right;">`fill`, `fill_diagonal`, `fill_with_identity`…</span>](#in-place-filling)
 * - [In-place swapping <span style="float:right;">`swap`, `swap_columns`…</span>](#in-place-swapping)
 * - [Set rows, columns, and diagonal <span style="float:right;">`set_column`, `set_diagonal`…</span>](#set-rows-columns-and-diagonal)
 *
 * #### Vector and matrix size modification
 * - [Rows and columns insertion <span style="float:right;">`insert_row`, `insert_column`…</span>](#rows-and-columns-insertion)
 * - [Rows and columns removal <span style="float:right;">`remove_row`, `remove column`…</span>](#rows-and-columns-removal)
 * - [Rows and columns extraction <span style="float:right;">`select_rows`, `select_columns`…</span>](#rows-and-columns-extraction)
 * - [Resizing and reshaping <span style="float:right;">`resize`, `reshape_generic`…</span>](#resizing-and-reshaping)
 * - [In-place resizing <span style="float:right;">`resize_mut`, `resize_vertically_mut`…</span>](#in-place-resizing)
 *
 * #### Matrix decomposition
 * - [Rectangular matrix decomposition <span style="float:right;">`qr`, `lu`, `svd`…</span>](#rectangular-matrix-decomposition)
 * - [Square matrix decomposition <span style="float:right;">`cholesky`, `symmetric_eigen`…</span>](#square-matrix-decomposition)
 *
 * #### Vector basis computation
 * - [Basis and orthogonalization <span style="float:right;">`orthonormal_subspace_basis`, `orthonormalize`…</span>](#basis-and-orthogonalization)
 *
 * # Type parameters
 * The generic `Matrix` type has four type parameters:
 * - `T`: for the matrix components scalar type.
 * - `R`: for the matrix number of rows.
 * - `C`: for the matrix number of columns.
 * - `S`: for the matrix data storage, i.e., the buffer that actually contains the matrix
 * components.
 *
 * The matrix dimensions parameters `R` and `C` can either be:
 * - type-level unsigned integer constants (e.g. `U1`, `U124`) from the `nalgebra::` root module.
 * All numbers from 0 to 127 are defined that way.
 * - type-level unsigned integer constants (e.g. `U1024`, `U10000`) from the `typenum::` crate.
 * Using those, you will not get error messages as nice as for numbers smaller than 128 defined on
 * the `nalgebra::` module.
 * - the special value `Dynamic` from the `nalgebra::` root module. This indicates that the
 * specified dimension is not known at compile-time. Note that this will generally imply that the
 * matrix data storage `S` performs a dynamic allocation and contains extra metadata for the
 * matrix shape.
 *
 * Note that mixing `Dynamic` with type-level unsigned integers is allowed. Actually, a
 * dynamically-sized column vector should be represented as a `Matrix<T, Dynamic, U1, S>` (given
 * some concrete types for `T` and a compatible data storage type `S`).
 */
typedef struct Matrix_f64__U3__U1__ArrayStorage_f64__3__1 {
  /**
   * The data storage that contains all the matrix components. Disappointed?
   *
   * Well, if you came here to see how you can access the matrix components,
   * you may be in luck: you can access the individual components of all vectors with compile-time
   * dimensions <= 6 using field notation like this:
   * `vec.x`, `vec.y`, `vec.z`, `vec.w`, `vec.a`, `vec.b`. Reference and assignation work too:
   * ```
   * # use nalgebra::Vector3;
   * let mut vec = Vector3::new(1.0, 2.0, 3.0);
   * vec.x = 10.0;
   * vec.y += 30.0;
   * assert_eq!(vec.x, 10.0);
   * assert_eq!(vec.y + 100.0, 132.0);
   * ```
   * Similarly, for matrices with compile-time dimensions <= 6, you can use field notation
   * like this: `mat.m11`, `mat.m42`, etc. The first digit identifies the row to address
   * and the second digit identifies the column to address. So `mat.m13` identifies the component
   * at the first row and third column (note that the count of rows and columns start at 1 instead
   * of 0 here. This is so we match the mathematical notation).
   *
   * For all matrices and vectors, independently from their size, individual components can
   * be accessed and modified using indexing: `vec[20]`, `mat[(20, 19)]`. Here the indexing
   * starts at 0 as you would expect.
   */
  ArrayStorage_f64__3__1 data;
} Matrix_f64__U3__U1__ArrayStorage_f64__3__1;

/**
 * A stack-allocated, 3-dimensional column vector.
 */
typedef struct Matrix_f64__U3__U1__ArrayStorage_f64__3__1 Vector3_f64;

typedef struct AxisAngle {
  Vector3_f64 axis;
  double theta;
} AxisAngle;

/**
 * A array-based statically sized matrix data storage.
 */
typedef double ArrayStorage_f64__4__1[1][4];

/**
 * The most generic column-major matrix (and vector) type.
 *
 * # Methods summary
 * Because `Matrix` is the most generic types used as a common representation of all matrices and
 * vectors of **nalgebra** this documentation page contains every single matrix/vector-related
 * method. In order to make browsing this page simpler, the next subsections contain direct links
 * to groups of methods related to a specific topic.
 *
 * #### Vector and matrix construction
 * - [Constructors of statically-sized vectors or statically-sized matrices](#constructors-of-statically-sized-vectors-or-statically-sized-matrices)
 *   (`Vector3`, `Matrix3x6`…)
 * - [Constructors of fully dynamic matrices](#constructors-of-fully-dynamic-matrices) (`DMatrix`)
 * - [Constructors of dynamic vectors and matrices with a dynamic number of rows](#constructors-of-dynamic-vectors-and-matrices-with-a-dynamic-number-of-rows)
 *   (`DVector`, `MatrixXx3`…)
 * - [Constructors of matrices with a dynamic number of columns](#constructors-of-matrices-with-a-dynamic-number-of-columns)
 *   (`Matrix2xX`…)
 * - [Generic constructors](#generic-constructors)
 *   (For code generic wrt. the vectors or matrices dimensions.)
 *
 * #### Computer graphics utilities for transformations
 * - [2D transformations as a Matrix3 <span style="float:right;">`new_rotation`…</span>](#2d-transformations-as-a-matrix3)
 * - [3D transformations as a Matrix4 <span style="float:right;">`new_rotation`, `new_perspective`, `look_at_rh`…</span>](#3d-transformations-as-a-matrix4)
 * - [Translation and scaling in any dimension <span style="float:right;">`new_scaling`, `new_translation`…</span>](#translation-and-scaling-in-any-dimension)
 * - [Append/prepend translation and scaling <span style="float:right;">`append_scaling`, `prepend_translation_mut`…</span>](#appendprepend-translation-and-scaling)
 * - [Transformation of vectors and points <span style="float:right;">`transform_vector`, `transform_point`…</span>](#transformation-of-vectors-and-points)
 *
 * #### Common math operations
 * - [Componentwise operations <span style="float:right;">`component_mul`, `component_div`, `inf`…</span>](#componentwise-operations)
 * - [Special multiplications <span style="float:right;">`tr_mul`, `ad_mul`, `kronecker`…</span>](#special-multiplications)
 * - [Dot/scalar product <span style="float:right;">`dot`, `dotc`, `tr_dot`…</span>](#dotscalar-product)
 * - [Cross product <span style="float:right;">`cross`, `perp`…</span>](#cross-product)
 * - [Magnitude and norms <span style="float:right;">`norm`, `normalize`, `metric_distance`…</span>](#magnitude-and-norms)
 * - [In-place normalization <span style="float:right;">`normalize_mut`, `try_normalize_mut`…</span>](#in-place-normalization)
 * - [Interpolation <span style="float:right;">`lerp`, `slerp`…</span>](#interpolation)
 * - [BLAS functions <span style="float:right;">`gemv`, `gemm`, `syger`…</span>](#blas-functions)
 * - [Swizzling <span style="float:right;">`xx`, `yxz`…</span>](#swizzling)
 * - [Triangular matrix extraction <span style="float:right;">`upper_triangle`, `lower_triangle`</span>](#triangular-matrix-extraction)
 *
 * #### Statistics
 * - [Common operations <span style="float:right;">`row_sum`, `column_mean`, `variance`…</span>](#common-statistics-operations)
 * - [Find the min and max components <span style="float:right;">`min`, `max`, `amin`, `amax`, `camin`, `cmax`…</span>](#find-the-min-and-max-components)
 * - [Find the min and max components (vector-specific methods) <span style="float:right;">`argmin`, `argmax`, `icamin`, `icamax`…</span>](#find-the-min-and-max-components-vector-specific-methods)
 *
 * #### Iteration, map, and fold
 * - [Iteration on components, rows, and columns <span style="float:right;">`iter`, `column_iter`…</span>](#iteration-on-components-rows-and-columns)
 * - [Elementwise mapping and folding <span style="float:right;">`map`, `fold`, `zip_map`…</span>](#elementwise-mapping-and-folding)
 * - [Folding or columns and rows <span style="float:right;">`compress_rows`, `compress_columns`…</span>](#folding-on-columns-and-rows)
 *
 * #### Vector and matrix slicing
 * - [Creating matrix slices from `&[T]` <span style="float:right;">`from_slice`, `from_slice_with_strides`…</span>](#creating-matrix-slices-from-t)
 * - [Creating mutable matrix slices from `&mut [T]` <span style="float:right;">`from_slice_mut`, `from_slice_with_strides_mut`…</span>](#creating-mutable-matrix-slices-from-mut-t)
 * - [Slicing based on index and length <span style="float:right;">`row`, `columns`, `slice`…</span>](#slicing-based-on-index-and-length)
 * - [Mutable slicing based on index and length <span style="float:right;">`row_mut`, `columns_mut`, `slice_mut`…</span>](#mutable-slicing-based-on-index-and-length)
 * - [Slicing based on ranges <span style="float:right;">`rows_range`, `columns_range`…</span>](#slicing-based-on-ranges)
 * - [Mutable slicing based on ranges <span style="float:right;">`rows_range_mut`, `columns_range_mut`…</span>](#mutable-slicing-based-on-ranges)
 *
 * #### In-place modification of a single matrix or vector
 * - [In-place filling <span style="float:right;">`fill`, `fill_diagonal`, `fill_with_identity`…</span>](#in-place-filling)
 * - [In-place swapping <span style="float:right;">`swap`, `swap_columns`…</span>](#in-place-swapping)
 * - [Set rows, columns, and diagonal <span style="float:right;">`set_column`, `set_diagonal`…</span>](#set-rows-columns-and-diagonal)
 *
 * #### Vector and matrix size modification
 * - [Rows and columns insertion <span style="float:right;">`insert_row`, `insert_column`…</span>](#rows-and-columns-insertion)
 * - [Rows and columns removal <span style="float:right;">`remove_row`, `remove column`…</span>](#rows-and-columns-removal)
 * - [Rows and columns extraction <span style="float:right;">`select_rows`, `select_columns`…</span>](#rows-and-columns-extraction)
 * - [Resizing and reshaping <span style="float:right;">`resize`, `reshape_generic`…</span>](#resizing-and-reshaping)
 * - [In-place resizing <span style="float:right;">`resize_mut`, `resize_vertically_mut`…</span>](#in-place-resizing)
 *
 * #### Matrix decomposition
 * - [Rectangular matrix decomposition <span style="float:right;">`qr`, `lu`, `svd`…</span>](#rectangular-matrix-decomposition)
 * - [Square matrix decomposition <span style="float:right;">`cholesky`, `symmetric_eigen`…</span>](#square-matrix-decomposition)
 *
 * #### Vector basis computation
 * - [Basis and orthogonalization <span style="float:right;">`orthonormal_subspace_basis`, `orthonormalize`…</span>](#basis-and-orthogonalization)
 *
 * # Type parameters
 * The generic `Matrix` type has four type parameters:
 * - `T`: for the matrix components scalar type.
 * - `R`: for the matrix number of rows.
 * - `C`: for the matrix number of columns.
 * - `S`: for the matrix data storage, i.e., the buffer that actually contains the matrix
 * components.
 *
 * The matrix dimensions parameters `R` and `C` can either be:
 * - type-level unsigned integer constants (e.g. `U1`, `U124`) from the `nalgebra::` root module.
 * All numbers from 0 to 127 are defined that way.
 * - type-level unsigned integer constants (e.g. `U1024`, `U10000`) from the `typenum::` crate.
 * Using those, you will not get error messages as nice as for numbers smaller than 128 defined on
 * the `nalgebra::` module.
 * - the special value `Dynamic` from the `nalgebra::` root module. This indicates that the
 * specified dimension is not known at compile-time. Note that this will generally imply that the
 * matrix data storage `S` performs a dynamic allocation and contains extra metadata for the
 * matrix shape.
 *
 * Note that mixing `Dynamic` with type-level unsigned integers is allowed. Actually, a
 * dynamically-sized column vector should be represented as a `Matrix<T, Dynamic, U1, S>` (given
 * some concrete types for `T` and a compatible data storage type `S`).
 */
typedef struct Matrix_f64__U4__U1__ArrayStorage_f64__4__1 {
  /**
   * The data storage that contains all the matrix components. Disappointed?
   *
   * Well, if you came here to see how you can access the matrix components,
   * you may be in luck: you can access the individual components of all vectors with compile-time
   * dimensions <= 6 using field notation like this:
   * `vec.x`, `vec.y`, `vec.z`, `vec.w`, `vec.a`, `vec.b`. Reference and assignation work too:
   * ```
   * # use nalgebra::Vector3;
   * let mut vec = Vector3::new(1.0, 2.0, 3.0);
   * vec.x = 10.0;
   * vec.y += 30.0;
   * assert_eq!(vec.x, 10.0);
   * assert_eq!(vec.y + 100.0, 132.0);
   * ```
   * Similarly, for matrices with compile-time dimensions <= 6, you can use field notation
   * like this: `mat.m11`, `mat.m42`, etc. The first digit identifies the row to address
   * and the second digit identifies the column to address. So `mat.m13` identifies the component
   * at the first row and third column (note that the count of rows and columns start at 1 instead
   * of 0 here. This is so we match the mathematical notation).
   *
   * For all matrices and vectors, independently from their size, individual components can
   * be accessed and modified using indexing: `vec[20]`, `mat[(20, 19)]`. Here the indexing
   * starts at 0 as you would expect.
   */
  ArrayStorage_f64__4__1 data;
} Matrix_f64__U4__U1__ArrayStorage_f64__4__1;

/**
 * A stack-allocated, 4-dimensional column vector.
 */
typedef struct Matrix_f64__U4__U1__ArrayStorage_f64__4__1 Vector4_f64;

/**
 * A quaternion. See the type alias `UnitQuaternion = Unit<Quaternion>` for a quaternion
 * that may be used as a rotation.
 */
typedef struct Quaternion_f64 {
  /**
   * This quaternion as a 4D vector of coordinates in the `[ x, y, z, w ]` storage order.
   */
  Vector4_f64 coords;
} Quaternion_f64;

typedef struct EulerAngles {
  double roll;
  double pitch;
  double yaw;
} EulerAngles;

/**
 * A wrapper that ensures the underlying algebraic entity has a unit norm.
 *
 * **It is likely that the only piece of documentation that you need in this page are:**
 * - **[The construction with normalization](#construction-with-normalization)**
 * - **[Data extraction and construction without normalization](#data-extraction-and-construction-without-normalization)**
 * - **[Interpolation between two unit vectors](#interpolation-between-two-unit-vectors)**
 *
 * All the other impl blocks you will see in this page are about [`UnitComplex`](crate::UnitComplex)
 * and [`UnitQuaternion`](crate::UnitQuaternion); both built on top of `Unit`.  If you are interested
 * in their documentation, read their dedicated pages directly.
 */
typedef struct Matrix_f64__U3__U1__ArrayStorage_f64__3__1 Unit_Matrix_f64__U3__U1__ArrayStorage_f64__3__1;

/**
 * A stack-allocated, 3-dimensional unit vector.
 */
typedef Unit_Matrix_f64__U3__U1__ArrayStorage_f64__3__1 UnitVector3_f64;

typedef struct OrientationVector {
  UnitVector3_f64 o_vector;
  double theta;
} OrientationVector;

/**
 * A array-based statically sized matrix data storage.
 */
typedef double ArrayStorage_f64__3__3[3][3];

/**
 * The most generic column-major matrix (and vector) type.
 *
 * # Methods summary
 * Because `Matrix` is the most generic types used as a common representation of all matrices and
 * vectors of **nalgebra** this documentation page contains every single matrix/vector-related
 * method. In order to make browsing this page simpler, the next subsections contain direct links
 * to groups of methods related to a specific topic.
 *
 * #### Vector and matrix construction
 * - [Constructors of statically-sized vectors or statically-sized matrices](#constructors-of-statically-sized-vectors-or-statically-sized-matrices)
 *   (`Vector3`, `Matrix3x6`…)
 * - [Constructors of fully dynamic matrices](#constructors-of-fully-dynamic-matrices) (`DMatrix`)
 * - [Constructors of dynamic vectors and matrices with a dynamic number of rows](#constructors-of-dynamic-vectors-and-matrices-with-a-dynamic-number-of-rows)
 *   (`DVector`, `MatrixXx3`…)
 * - [Constructors of matrices with a dynamic number of columns](#constructors-of-matrices-with-a-dynamic-number-of-columns)
 *   (`Matrix2xX`…)
 * - [Generic constructors](#generic-constructors)
 *   (For code generic wrt. the vectors or matrices dimensions.)
 *
 * #### Computer graphics utilities for transformations
 * - [2D transformations as a Matrix3 <span style="float:right;">`new_rotation`…</span>](#2d-transformations-as-a-matrix3)
 * - [3D transformations as a Matrix4 <span style="float:right;">`new_rotation`, `new_perspective`, `look_at_rh`…</span>](#3d-transformations-as-a-matrix4)
 * - [Translation and scaling in any dimension <span style="float:right;">`new_scaling`, `new_translation`…</span>](#translation-and-scaling-in-any-dimension)
 * - [Append/prepend translation and scaling <span style="float:right;">`append_scaling`, `prepend_translation_mut`…</span>](#appendprepend-translation-and-scaling)
 * - [Transformation of vectors and points <span style="float:right;">`transform_vector`, `transform_point`…</span>](#transformation-of-vectors-and-points)
 *
 * #### Common math operations
 * - [Componentwise operations <span style="float:right;">`component_mul`, `component_div`, `inf`…</span>](#componentwise-operations)
 * - [Special multiplications <span style="float:right;">`tr_mul`, `ad_mul`, `kronecker`…</span>](#special-multiplications)
 * - [Dot/scalar product <span style="float:right;">`dot`, `dotc`, `tr_dot`…</span>](#dotscalar-product)
 * - [Cross product <span style="float:right;">`cross`, `perp`…</span>](#cross-product)
 * - [Magnitude and norms <span style="float:right;">`norm`, `normalize`, `metric_distance`…</span>](#magnitude-and-norms)
 * - [In-place normalization <span style="float:right;">`normalize_mut`, `try_normalize_mut`…</span>](#in-place-normalization)
 * - [Interpolation <span style="float:right;">`lerp`, `slerp`…</span>](#interpolation)
 * - [BLAS functions <span style="float:right;">`gemv`, `gemm`, `syger`…</span>](#blas-functions)
 * - [Swizzling <span style="float:right;">`xx`, `yxz`…</span>](#swizzling)
 * - [Triangular matrix extraction <span style="float:right;">`upper_triangle`, `lower_triangle`</span>](#triangular-matrix-extraction)
 *
 * #### Statistics
 * - [Common operations <span style="float:right;">`row_sum`, `column_mean`, `variance`…</span>](#common-statistics-operations)
 * - [Find the min and max components <span style="float:right;">`min`, `max`, `amin`, `amax`, `camin`, `cmax`…</span>](#find-the-min-and-max-components)
 * - [Find the min and max components (vector-specific methods) <span style="float:right;">`argmin`, `argmax`, `icamin`, `icamax`…</span>](#find-the-min-and-max-components-vector-specific-methods)
 *
 * #### Iteration, map, and fold
 * - [Iteration on components, rows, and columns <span style="float:right;">`iter`, `column_iter`…</span>](#iteration-on-components-rows-and-columns)
 * - [Elementwise mapping and folding <span style="float:right;">`map`, `fold`, `zip_map`…</span>](#elementwise-mapping-and-folding)
 * - [Folding or columns and rows <span style="float:right;">`compress_rows`, `compress_columns`…</span>](#folding-on-columns-and-rows)
 *
 * #### Vector and matrix slicing
 * - [Creating matrix slices from `&[T]` <span style="float:right;">`from_slice`, `from_slice_with_strides`…</span>](#creating-matrix-slices-from-t)
 * - [Creating mutable matrix slices from `&mut [T]` <span style="float:right;">`from_slice_mut`, `from_slice_with_strides_mut`…</span>](#creating-mutable-matrix-slices-from-mut-t)
 * - [Slicing based on index and length <span style="float:right;">`row`, `columns`, `slice`…</span>](#slicing-based-on-index-and-length)
 * - [Mutable slicing based on index and length <span style="float:right;">`row_mut`, `columns_mut`, `slice_mut`…</span>](#mutable-slicing-based-on-index-and-length)
 * - [Slicing based on ranges <span style="float:right;">`rows_range`, `columns_range`…</span>](#slicing-based-on-ranges)
 * - [Mutable slicing based on ranges <span style="float:right;">`rows_range_mut`, `columns_range_mut`…</span>](#mutable-slicing-based-on-ranges)
 *
 * #### In-place modification of a single matrix or vector
 * - [In-place filling <span style="float:right;">`fill`, `fill_diagonal`, `fill_with_identity`…</span>](#in-place-filling)
 * - [In-place swapping <span style="float:right;">`swap`, `swap_columns`…</span>](#in-place-swapping)
 * - [Set rows, columns, and diagonal <span style="float:right;">`set_column`, `set_diagonal`…</span>](#set-rows-columns-and-diagonal)
 *
 * #### Vector and matrix size modification
 * - [Rows and columns insertion <span style="float:right;">`insert_row`, `insert_column`…</span>](#rows-and-columns-insertion)
 * - [Rows and columns removal <span style="float:right;">`remove_row`, `remove column`…</span>](#rows-and-columns-removal)
 * - [Rows and columns extraction <span style="float:right;">`select_rows`, `select_columns`…</span>](#rows-and-columns-extraction)
 * - [Resizing and reshaping <span style="float:right;">`resize`, `reshape_generic`…</span>](#resizing-and-reshaping)
 * - [In-place resizing <span style="float:right;">`resize_mut`, `resize_vertically_mut`…</span>](#in-place-resizing)
 *
 * #### Matrix decomposition
 * - [Rectangular matrix decomposition <span style="float:right;">`qr`, `lu`, `svd`…</span>](#rectangular-matrix-decomposition)
 * - [Square matrix decomposition <span style="float:right;">`cholesky`, `symmetric_eigen`…</span>](#square-matrix-decomposition)
 *
 * #### Vector basis computation
 * - [Basis and orthogonalization <span style="float:right;">`orthonormal_subspace_basis`, `orthonormalize`…</span>](#basis-and-orthogonalization)
 *
 * # Type parameters
 * The generic `Matrix` type has four type parameters:
 * - `T`: for the matrix components scalar type.
 * - `R`: for the matrix number of rows.
 * - `C`: for the matrix number of columns.
 * - `S`: for the matrix data storage, i.e., the buffer that actually contains the matrix
 * components.
 *
 * The matrix dimensions parameters `R` and `C` can either be:
 * - type-level unsigned integer constants (e.g. `U1`, `U124`) from the `nalgebra::` root module.
 * All numbers from 0 to 127 are defined that way.
 * - type-level unsigned integer constants (e.g. `U1024`, `U10000`) from the `typenum::` crate.
 * Using those, you will not get error messages as nice as for numbers smaller than 128 defined on
 * the `nalgebra::` module.
 * - the special value `Dynamic` from the `nalgebra::` root module. This indicates that the
 * specified dimension is not known at compile-time. Note that this will generally imply that the
 * matrix data storage `S` performs a dynamic allocation and contains extra metadata for the
 * matrix shape.
 *
 * Note that mixing `Dynamic` with type-level unsigned integers is allowed. Actually, a
 * dynamically-sized column vector should be represented as a `Matrix<T, Dynamic, U1, S>` (given
 * some concrete types for `T` and a compatible data storage type `S`).
 */
typedef struct Matrix_f64__Const_3_____Const_3_____ArrayStorage_f64__3__3 {
  /**
   * The data storage that contains all the matrix components. Disappointed?
   *
   * Well, if you came here to see how you can access the matrix components,
   * you may be in luck: you can access the individual components of all vectors with compile-time
   * dimensions <= 6 using field notation like this:
   * `vec.x`, `vec.y`, `vec.z`, `vec.w`, `vec.a`, `vec.b`. Reference and assignation work too:
   * ```
   * # use nalgebra::Vector3;
   * let mut vec = Vector3::new(1.0, 2.0, 3.0);
   * vec.x = 10.0;
   * vec.y += 30.0;
   * assert_eq!(vec.x, 10.0);
   * assert_eq!(vec.y + 100.0, 132.0);
   * ```
   * Similarly, for matrices with compile-time dimensions <= 6, you can use field notation
   * like this: `mat.m11`, `mat.m42`, etc. The first digit identifies the row to address
   * and the second digit identifies the column to address. So `mat.m13` identifies the component
   * at the first row and third column (note that the count of rows and columns start at 1 instead
   * of 0 here. This is so we match the mathematical notation).
   *
   * For all matrices and vectors, independently from their size, individual components can
   * be accessed and modified using indexing: `vec[20]`, `mat[(20, 19)]`. Here the indexing
   * starts at 0 as you would expect.
   */
  ArrayStorage_f64__3__3 data;
} Matrix_f64__Const_3_____Const_3_____ArrayStorage_f64__3__3;

/**
 * A statically sized column-major matrix with `R` rows and `C` columns.
 *
 * **Because this is an alias, not all its methods are listed here. See the [`Matrix`](crate::base::Matrix) type too.**
 */
typedef struct Matrix_f64__Const_3_____Const_3_____ArrayStorage_f64__3__3 SMatrix_f64__3__3;

/**
 * A rotation matrix.
 *
 * This is also known as an element of a Special Orthogonal (SO) group.
 * The `Rotation` type can either represent a 2D or 3D rotation, represented as a matrix.
 * For a rotation based on quaternions, see [`UnitQuaternion`](crate::UnitQuaternion) instead.
 *
 * Note that instead of using the [`Rotation`](crate::Rotation) type in your code directly, you should use one
 * of its aliases: [`Rotation2`](crate::Rotation2), or [`Rotation3`](crate::Rotation3). Though
 * keep in mind that all the documentation of all the methods of these aliases will also appears on
 * this page.
 *
 * # Construction
 * * [Identity <span style="float:right;">`identity`</span>](#identity)
 * * [From a 2D rotation angle <span style="float:right;">`new`…</span>](#construction-from-a-2d-rotation-angle)
 * * [From an existing 2D matrix or rotations <span style="float:right;">`from_matrix`, `rotation_between`, `powf`…</span>](#construction-from-an-existing-2d-matrix-or-rotations)
 * * [From a 3D axis and/or angles <span style="float:right;">`new`, `from_euler_angles`, `from_axis_angle`…</span>](#construction-from-a-3d-axis-andor-angles)
 * * [From a 3D eye position and target point <span style="float:right;">`look_at`, `look_at_lh`, `rotation_between`…</span>](#construction-from-a-3d-eye-position-and-target-point)
 * * [From an existing 3D matrix or rotations <span style="float:right;">`from_matrix`, `rotation_between`, `powf`…</span>](#construction-from-an-existing-3d-matrix-or-rotations)
 *
 * # Transformation and composition
 * Note that transforming vectors and points can be done by multiplication, e.g., `rotation * point`.
 * Composing an rotation with another transformation can also be done by multiplication or division.
 * * [3D axis and angle extraction <span style="float:right;">`angle`, `euler_angles`, `scaled_axis`, `angle_to`…</span>](#3d-axis-and-angle-extraction)
 * * [2D angle extraction <span style="float:right;">`angle`, `angle_to`…</span>](#2d-angle-extraction)
 * * [Transformation of a vector or a point <span style="float:right;">`transform_vector`, `inverse_transform_point`…</span>](#transformation-of-a-vector-or-a-point)
 * * [Transposition and inversion <span style="float:right;">`transpose`, `inverse`…</span>](#transposition-and-inversion)
 * * [Interpolation <span style="float:right;">`slerp`…</span>](#interpolation)
 *
 * # Conversion
 * * [Conversion to a matrix <span style="float:right;">`matrix`, `to_homogeneous`…</span>](#conversion-to-a-matrix)
 *
 */
typedef struct Rotation_f64__3 {
  SMatrix_f64__3__3 matrix;
} Rotation_f64__3;

/**
 * A 3-dimensional rotation matrix.
 *
 * **Because this is an alias, not all its methods are listed here. See the [`Rotation`](crate::Rotation) type too.**
 */
typedef struct Rotation_f64__3 Rotation3_f64;

/**
 * Initialize a tokio runtime to run a gRPC client/sever, user should call this function before trying to dial to a Robot
 * Returns a pointer to a [`DialFfi`]
 */
struct DialFfi *init_rust_runtime(void);

/**
 * Returns a path to a proxy to a robot
 * # Safety
 *
 * This function must be called from another language. See [`dial`](mod@crate::rpc::dial) for dial from rust
 * The function returns a path to a proxy as a [`c_char`], the string should be freed with free_string when not needed anymore.
 * When falling to dial it will return a NULL pointer
 * # Arguments
 * * `c_uri` a C-style string representing the address of robot you want to connect to
 * * `c_type` a C-style string representing the type of robot's secret you want to use, set to NULL if you don't need authentication
 * * `c_payload` a C-style string that is the robot's secret, set to NULL if you don't need authentication
 * * `c_allow_insecure` a bool, set to true when allowing insecure connection to your robot
 * * `c_timeout` a float, set how many seconds we should try to dial before timing out
 * * `rt_ptr` a pointer to a rust runtime previously obtained with init_rust_runtime
 */
char *dial(const char *c_uri,
           const char *c_entity,
           const char *c_type,
           const char *c_payload,
           bool c_allow_insec,
           float c_timeout,
           struct DialFfi *rt_ptr);

/**
 * This function must be used to free the path returned by the [`dial`] function
 * # Safety
 *
 * The function must not be called more than once with the same pointer
 * # Arguments
 * * `c_char` a pointer to the string returned by [`dial`]
 */
void free_string(char *s);

/**
 * This function must be used the free a rust runtime returned by [`init_rust_runtime`] the function will signal any
 * opened server to shutdown. Further transaction on any proxy will not work anymore.
 * # Safety
 *
 * The function must not be called more than once with the same pointer
 * # Arguments
 * * `rt_prt` a pointer to the string returned by [`init_rust_runtime`]
 */
int32_t free_rust_runtime(struct DialFfi *rt_ptr);

/**
 * Free memory at the address of the axis angle pointer.
 *
 * # Safety
 *
 * Outer processes that work with axis angles via the FFI interface MUST remember
 * to call this function when finished with an axis angle instance
 */
void free_axis_angles_memory(struct AxisAngle *ptr);

/**
 * Initialize axis angle from raw components and retrieve the C pointer
 * to its address.
 *
 * # Safety
 *
 * When finished with the underlying axis angle initialized by this function
 * the caller must remember to free the axis angle memory using the
 * free_axis_angles_memory FFI function
 */
struct AxisAngle *new_axis_angle(double x, double y, double z, double theta);

/**
 * Converts a quaternion into an R4 axis angle. The return value is a pointer
 * to a list of [x, y, x, theta], where (x,y,z) are the axis vector components
 * and theta is the rotation about the axis in radians. A zero quaternion returns
 * a zero axis angle. In the event of an error from the nalgebra crate, a zero
 * axis angle is also returned.
 *
 * # Safety
 *
 * When finished with the underlying quaternion passed to this function
 * the caller must remember to free the quaternion memory using the
 * free_quaternion_memory FFI function and the axis angle memory using
 * the free_array_memory function
 */
struct AxisAngle *axis_angle_from_quaternion(const struct Quaternion_f64 *quat);

/**
 * Free memory at the address of the euler angles pointer.
 *
 * # Safety
 *
 * Outer processes that work with EulerAngles via the FFI interface MUST remember
 * to call this function when finished with a euler angles instance
 */
void free_euler_angles_memory(struct EulerAngles *ptr);

/**
 * Initialize euler angles from raw components and retrieve the C pointer
 * to its address.
 *
 * # Safety
 *
 * When finished with the underlying euler angles initialized by this function
 * the caller must remember to free the euler angles memory using the
 * free_euler_angles_memory FFI function
 */
struct EulerAngles *new_euler_angles(double roll, double pitch, double yaw);

/**
 * Converts a quaternion into euler angles (in radians). The euler angles are
 * represented according to the Tait-Bryan formalism and applied
 * in the Z-Y'-X" order (where Z -> yaw, Y -> pitch, X -> roll).
 *
 * # Safety
 *
 * When finished with the underlying quaternion passed to this function
 * the caller must remember to free the quaternion memory using the
 * free_quaternion_memory FFI function and the euler angles memory using
 * the free_euler_angles_memory function
 */
struct EulerAngles *euler_angles_from_quaternion(const struct Quaternion_f64 *quat_ptr);

/**
 * Free memory at the address of the orientation vector pointer. Outer processes
 * that work with OrientationVectors via the FFI interface MUST remember
 * to call this function when finished with a OrientationVector instance
 *
 * # Safety
 */
void free_orientation_vector_memory(struct OrientationVector *ptr);

/**
 * Initialize an orientation vector from raw components and retrieve the C pointer
 * to its address.
 *
 * # Safety
 *
 * When finished with the underlying orientation vector initialized by this function
 * the caller must remember to free the orientation vector memory using the
 * free_orientation_vector_memory FFI function
 */
struct OrientationVector *new_orientation_vector(double o_x, double o_y, double o_z, double theta);

/**
 * Get the components of an orientation vector as a list of C doubles, the order of the
 * components will be (o_x, o_y, o_z, theta).
 *
 * # Safety
 *
 * When finished with the underlying orientation_vector passed to this function
 * the caller must remember to free the orientation_vector memory using the
 * free_orientation_vector_memory FFI function
 */
const double *orientation_vector_get_components(const struct OrientationVector *ov_ptr);

/**
 * Converts a quaternion into an orientation vector.
 *
 * # Safety
 *
 * When finished with the underlying quaternion passed to this function
 * the caller must remember to free the quaternion memory using the
 * free_quaternion_memory FFI function and the orientation-vector memory using
 * the free_orientation_vector_memory function
 */
struct OrientationVector *orientation_vector_from_quaternion(const struct Quaternion_f64 *quat_ptr);

/**
 * Free memory of an array of orientation vector components at the given address.
 *
 * # Safety
 *
 * Outer processes that request the components of a orientation vector should call this function
 * to free the memory allocated to the array once finished
 */
void free_orientation_vector_components(double *ptr);

/**
 * Initialize a quaternion from raw components and retrieve the C pointer
 * to its address.
 *
 * # Safety
 *
 * When finished with the underlying quaternion initialized by this function
 * the caller must remember to free the quaternion memory using the
 * free_quaternion_memory FFI function
 */
struct Quaternion_f64 *new_quaternion(double real, double i, double j, double k);

/**
 * Initialize a quaternion from a real part and a C pointer to a Vector3
 * and retrieve the C pointer to its address.
 *
 * # Safety
 *
 * When finished with the underlying quaternion initialized by this function
 * the caller must remember to free the quaternion memory using the
 * free_quaternion_memory FFI function
 */
struct Quaternion_f64 *new_quaternion_from_vector(double real, const Vector3_f64 *imag_ptr);

/**
 * Free memory at the address of the quaternion pointer.
 *
 * # Safety
 *
 * Outer processes that work with Quaternions via the FFI interface MUST remember
 * to call this function when finished with a quaternion
 */
void free_quaternion_memory(struct Quaternion_f64 *ptr);

/**
 * Get the components of a quaternion as a list of C doubles, the order of the
 * components will be (real, i, j, k).
 *
 * # Safety
 *
 * When finished with the underlying quaternion passed to this function
 * the caller must remember to free the quaternion memory using the
 * free_quaternion_memory FFI function
 */
const double *quaternion_get_components(const struct Quaternion_f64 *quat_ptr);

/**
 * Set the real component of an existing quaternion stored at the address
 * of a pointer.
 *
 * # Safety
 *
 * When finished with the underlying quaternion passed to this function
 * the caller must remember to free the quaternion memory using the
 * free_quaternion_memory FFI function
 */
void quaternion_set_real(struct Quaternion_f64 *quat_ptr, double real);

/**
 * Set the i component of an existing quaternion stored at the address
 * of a pointer.
 *
 * # Safety
 *
 * When finished with the underlying quaternion passed to this function
 * the caller must remember to free the quaternion memory using the
 * free_quaternion_memory FFI function
 */
void quaternion_set_i(struct Quaternion_f64 *quat_ptr, double i);

/**
 * Set the j component of an existing quaternion stored at the address
 * of a pointer.
 *
 * # Safety
 *
 * When finished with the underlying quaternion passed to this function
 * the caller must remember to free the quaternion memory using the
 * free_quaternion_memory FFI function
 */
void quaternion_set_j(struct Quaternion_f64 *quat_ptr, double j);

/**
 * Set the k component of an existing quaternion stored at the address
 * of a pointer.
 *
 * # Safety
 *
 * When finished with the underlying quaternion passed to this function
 * the caller must remember to free the quaternion memory using the
 * free_quaternion_memory FFI function
 */
void quaternion_set_k(struct Quaternion_f64 *quat_ptr, double k);

/**
 * Set all of the components of an existing quaternion stored at the address
 * of a pointer
 *
 * # Safety
 *
 * When finished with the underlying quaternion passed to this function
 * the caller must remember to free the quaternion memory using the
 * free_quaternion_memory FFI function
 */
void quaternion_set_components(struct Quaternion_f64 *quat_ptr,
                               double real,
                               double i,
                               double j,
                               double k);

/**
 * Set the imaginary components of an existing quaternion stored at
 * the address of a pointer (quat_ptr) from the components of a 3-vector
 * (stored at vec_ptr). The convention is x -> i, y -> j, z -> k
 *
 * # Safety
 *
 * When finished with the underlying quaternion passed to this function
 * the caller must remember to free the quaternion memory using the
 * free_quaternion_memory FFI function (the same applies for the vector
 * stored at vec_ptr)
 */
void quaternion_set_imag_from_vector(struct Quaternion_f64 *quat_ptr, const Vector3_f64 *vec_ptr);

/**
 * Copies the imaginary components to a 3-vector (using x -> i, y -> j
 * z -> k) and returns a pointer to the memory address of the resulting
 * vector
 *
 * # Safety
 *
 * When finished with the underlying quaternion initialized by this function
 * the caller must remember to free the quaternion memory using the
 * free_quaternion_memory FFI function
 */
Vector3_f64 *quaternion_get_imaginary_vector(const struct Quaternion_f64 *quat_ptr);

/**
 * Normalizes an existing quaternion stored at the address of
 * a pointer (quat_ptr)
 *
 * # Safety
 *
 * When finished with the underlying quaternion passed to this function
 * the caller must remember to free the quaternion memory using the
 * free_quaternion_memory FFI function
 */
void normalize_quaternion(struct Quaternion_f64 *quat_ptr);

/**
 * Initializes a normalized copy of a quaternion stored at the
 * address of a pointer (quat_ptr) and returns a pointer to the
 * memory of the result
 *
 * # Safety
 *
 * The caller must remember to free the quaternion memory of
 * *both* the input and output quaternions when finished with them
 * using the free_quaternion_memory FFI function
 */
struct Quaternion_f64 *quaternion_get_normalized(const struct Quaternion_f64 *quat_ptr);

/**
 * Returns the result of rotating a vector by a quaternion
 *
 * # Safety
 *
 * The caller must remember to free the quaternion memory and
 * the memory of both vectors when finished with them using the
 * free_quaternion_memory and free_vector_memory FFI functions
 */
Vector3_f64 *quaternion_rotate_vector(const struct Quaternion_f64 *quat_ptr,
                                      const Vector3_f64 *vec_ptr);

/**
 * Converts from euler angles (in radians) to a quaternion. The euler angles are expected to
 * be represented according to the Tait-Bryan formalism and applied in the Z-Y'-X"
 * order (where Z -> yaw, Y -> pitch, X -> roll)
 *
 * # Safety
 *
 * When finished with the underlying quaternion initialized by this function
 * the caller must remember to free the quaternion memory using the
 * free_quaternion_memory FFI function
 */
struct Quaternion_f64 *quaternion_from_euler_angles(double roll, double pitch, double yaw);

/**
 * Converts from an axis angle given by a vector's x, y, z components
 * and a rotation theta (in radians) about the vector into a quaternion
 *
 * # Safety
 *
 * When finished with the underlying quaternion initialized by this function
 * the caller must remember to free the quaternion memory using the
 * free_quaternion_memory FFI function
 */
struct Quaternion_f64 *quaternion_from_axis_angle(double x, double y, double z, double theta);

/**
 * Converts from an axis angle whose vector is given by a pointer
 * to a nalgebra::Vector3<f64> instance and a rotation theta (in radians)
 * about the vector to a quaternion
 *
 * # Safety
 *
 * When finished with the underlying quaternion initialized by this function
 * the caller must remember to free the quaternion memory using the
 * free_quaternion_memory FFI function. Similarly the free_vector_memory should
 * be called when finished with the axis angle vector
 */
struct Quaternion_f64 *quaternion_from_axis_angle_vector(double theta,
                                                         const Vector3_f64 *axis_angle_vec_ptr);

/**
 * Converts from a pointer to a Rotation3<f64> to a quaternion
 *
 * # Safety
 *
 * When finished with the underlying quaternion initialized by this function
 * the caller must remember to free the quaternion memory using the
 * free_quaternion_memory FFI function
 */
struct Quaternion_f64 *quaternion_from_rotation_matrix(const Rotation3_f64 *rot_ptr);

/**
 * Converts from a pointer to an OrientationVector to a quaternion
 *
 * # Safety
 *
 * When finished with the underlying quaternion initialized by this function
 * the caller must remember to free the quaternion memory using the
 * free_quaternion_memory FFI function
 */
struct Quaternion_f64 *quaternion_from_orientation_vector(const struct OrientationVector *o_vec_ptr);

/**
 * Scales an existing quaternion stored at the address of
 * a pointer (quat_ptr) by a factor (float)
 *
 * # Safety
 *
 * When finished with the underlying quaternion passed to this function
 * the caller must remember to free the quaternion memory using the
 * free_quaternion_memory FFI function
 */
void scale_quaternion(struct Quaternion_f64 *quat_ptr, double factor);

/**
 * Initializes a copy of the quaternion stored at the address of a pointer (quat_ptr)
 * scaled by a factor (float) and returns a pointer to the memory of the result
 *
 * # Safety
 *
 * The caller must remember to free the quaternion memory of
 * *both* the input and output quaternions when finished with them
 * using the free_quaternion_memory FFI function
 */
struct Quaternion_f64 *quaternion_get_scaled(const struct Quaternion_f64 *quat_ptr, double factor);

/**
 * Initializes a quaternion that is the conjugate of one stored
 * at the address of a pointer (quat_ptr)and returns a pointer
 * to the memory of the result
 *
 * # Safety
 *
 * The caller must remember to free the quaternion memory of
 * *both* the input and output quaternions when finished with them
 * using the free_quaternion_memory FFI function
 */
struct Quaternion_f64 *quaternion_get_conjugate(const struct Quaternion_f64 *quat_ptr);

/**
 * Adds two quaternions and returns a pointer to the
 * memory of the result
 *
 * # Safety
 *
 * The caller must remember to free the quaternion memory of *both* the input and
 * output quaternions when finished with them using the free_quaternion_memory FFI function
 */
struct Quaternion_f64 *quaternion_add(const struct Quaternion_f64 *quat_ptr_1,
                                      const struct Quaternion_f64 *quat_ptr_2);

/**
 * Subtracts two quaternions and returns a pointer to the
 * memory of the result
 *
 * # Safety
 *
 * The caller must remember to free the quaternion memory of *both* the input and
 * output quaternions when finished with them using the free_quaternion_memory FFI function
 */
struct Quaternion_f64 *quaternion_subtract(const struct Quaternion_f64 *quat_ptr_1,
                                           const struct Quaternion_f64 *quat_ptr_2);

/**
 * Computes the Hamiltonian product of two quaternions and
 * returns a pointer to the memory of the result
 *
 * # Safety
 *
 * The caller must remember to free the quaternion memory of *both* the input and
 * output quaternions when finished with them using the free_quaternion_memory FFI function
 */
struct Quaternion_f64 *quaternion_hamiltonian_product(const struct Quaternion_f64 *quat_ptr_1,
                                                      const struct Quaternion_f64 *quat_ptr_2);

/**
 * Free memory of an array of quaternion components at the given address.
 *
 * # Safety
 *
 * Outer processes that request the components of a quaternion should call this function
 * to free the memory allocated to the array once finished
 */
void free_quaternion_components(double *ptr);

/**
 * Free memory at the address of the rotation matrix pointer. Outer processes
 * that work with RotationMatrices via the FFI interface MUST remember
 * to call this function when finished with a rotation matrix
 *
 * # Safety
 */
void free_rotation_matrix_memory(Rotation3_f64 *ptr);

/**
 * Initialize a 3D rotation matrix from raw components and retrieve the C pointer
 * to its address. This function DOES NOT check whether the matrix elements provided
 * form a valid member of SO(3)
 *
 * # Safety
 *
 * When finished with the underlying rotation matrix initialized by this function
 * the caller must remember to free the rotation matrix memory using the
 * free_rotation_matrix_memory FFI function
 */
Rotation3_f64 *new_rotation_matrix(const double (*elements)[9]);

/**
 * Converts a quaternion into a 3D rotation matrix (a Rotation<f64, 3>
 * from the nalgebra crate)
 *
 * # Safety
 *
 * When finished with the underlying quaternion passed to this function
 * the caller must remember to free the quaternion memory using the
 * free_quaternion_memory FFI function and the rotation matrix memory using
 * the free_rotation_matrix_memory function
 */
Rotation3_f64 *rotation_matrix_from_quaternion(const struct Quaternion_f64 *quat);

/**
 * Initialize a 3-vector from raw components and retrieve the C pointer
 * to its address.
 *
 * # Safety
 *
 * When finished with the underlying vector initialized by this function
 * the caller must remember to free the vector memory using the
 * free_vector_memory FFI function
 */
Vector3_f64 *new_vector3(double x, double y, double z);

/**
 * Free memory at the address of the vector pointer.
 *
 * # Safety
 * Outer processes that work with Vectors via the FFI interface MUST remember
 * to call this function when finished with a vector
 */
void free_vector_memory(Vector3_f64 *ptr);

/**
 * Get the components of a vector as a list of C doubles, the order of the
 * components will be (x, y, z).
 *
 * # Safety
 *
 * When finished with the underlying vector, the caller must remember to
 * free the vector memory using the free_vector_memory FFI function
 */
const double *vector_get_components(const Vector3_f64 *vec_ptr);

/**
 * Set the x component of an existing vector stored at the address
 * of a pointer.
 *
 * # Safety
 *
 * When finished with the underlying vector, the caller must remember to
 * free the vector memory using the free_vector_memory FFI function
 */
void vector_set_x(Vector3_f64 *vec_ptr, double x_val);

/**
 * Set the y component of an existing vector stored at the address
 * of a pointer.
 *
 * # Safety
 *
 * When finished with the underlying vector, the caller must remember to
 * free the vector memory using the free_vector_memory FFI function
 */
void vector_set_y(Vector3_f64 *vec_ptr, double y_val);

/**
 * Set the z component of an existing vector stored at the address
 * of a pointer.
 *
 * # Safety
 *
 * When finished with the underlying vector, the caller must remember to
 * free the vector memory using the free_vector_memory FFI function
 */
void vector_set_z(Vector3_f64 *vec_ptr, double z_val);

/**
 * Normalizes an existing vector stored at the address of
 * a pointer (vec_ptr)
 *
 * # Safety
 *
 * When finished with the underlying vector, the caller must remember to
 * free the vector memory using the free_vector_memory FFI function
 */
void normalize_vector(Vector3_f64 *vec_ptr);

/**
 * Initializes a normalized copy of a vector stored at the
 * address of a pointer (vec_ptr) and returns a pointer to the
 * memory of the result
 *
 * # Safety
 *
 * The caller must remember to free the vector memory of *both* the input and
 * output vectors when finished with them using the free_vector_memory FFI function
 */
Vector3_f64 *vector_get_normalized(const Vector3_f64 *vec_ptr);

/**
 * Scales an existing vector stored at the address of
 * a pointer (vec_ptr) by a float factor
 *
 * # Safety
 *
 * When finished with the underlying vector, the caller must remember to
 * free the vector memory using the free_vector_memory FFI function
 */
void scale_vector(Vector3_f64 *vec_ptr, double factor);

/**
 * Initializes a scaled copy of a vector stored at the
 * address of a pointer (vec_ptr) and returns a pointer to the
 * memory of the result
 *
 * # Safety
 *
 * The caller must remember to free the vector memory of *both* the input and
 * output vectors when finished with them using the free_vector_memory FFI function
 */
Vector3_f64 *vector_get_scaled(const Vector3_f64 *vec_ptr, double factor);

/**
 * Adds two vectors and returns a pointer to the
 * memory of the result
 *
 * # Safety
 *
 * The caller must remember to free the vector memory of *both* the input and
 * output vectors when finished with them using the free_vector_memory FFI function
 */
Vector3_f64 *vector_add(const Vector3_f64 *vec_ptr_1, const Vector3_f64 *vec_ptr_2);

/**
 * Subtracts two vectors and returns a pointer to the
 * memory of the result
 *
 * # Safety
 *
 * The caller must remember to free the vector memory of *both* the input and
 * output vectors when finished with them using the free_vector_memory FFI function
 */
Vector3_f64 *vector_subtract(const Vector3_f64 *vec_ptr_1, const Vector3_f64 *vec_ptr_2);

/**
 * Computes the dot product of two vectors
 *
 * # Safety
 *
 * The caller must remember to free the vector memory of the input vectors
 * when finished with them using the free_vector_memory FFI function
 */
double vector_dot_product(const Vector3_f64 *vec_ptr_1, const Vector3_f64 *vec_ptr_2);

/**
 * Computes the cross product of two vectors and returns
 * a pointer to the memory of the result
 *
 * # Safety
 *
 * The caller must remember to free the vector memory of *both* the input and
 * output vectors when finished with them using the free_vector_memory FFI function
 */
Vector3_f64 *vector_cross_product(Vector3_f64 *vec_ptr_1, Vector3_f64 *vec_ptr_2);

/**
 * Free memory of an array of vector components at the given address.
 *
 * # Safety
 *
 * Outer processes that request the components of a vector should call this function
 * to free the memory allocated to the array once finished
 */
void free_vector_components(double *ptr);
